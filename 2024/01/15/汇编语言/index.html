<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="基础知识【8086汇编入门】 引言汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效的控制系统进行运作。 &#x3D;&#x3D;机器语言&#x3D;&#x3D; 机器语言是机器指令的集合。展开来说就是一台机器可以正确执行的命令 &#x3D;&#x3D;汇编语言&#x3D;&#x3D;  汇编语言的主体是汇编指令 汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言">
<meta property="og:url" content="http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="psych&#39;s blog">
<meta property="og:description" content="基础知识【8086汇编入门】 引言汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效的控制系统进行运作。 &#x3D;&#x3D;机器语言&#x3D;&#x3D; 机器语言是机器指令的集合。展开来说就是一台机器可以正确执行的命令 &#x3D;&#x3D;汇编语言&#x3D;&#x3D;  汇编语言的主体是汇编指令 汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030133241106.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030135425947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240111183554301.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231031135144429.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20190321194022547.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240115220506695.png">
<meta property="article:published_time" content="2024-01-15T13:56:18.000Z">
<meta property="article:modified_time" content="2024-01-15T14:05:16.884Z">
<meta property="article:author" content="psych">
<meta property="article:tag" content="课内">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030133241106.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>汇编语言</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Article</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/01/16/asphyxia-0/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/01/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&text=汇编语言"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&is_video=false&description=汇编语言"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=汇编语言&body=Check out this article: http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&name=汇编语言&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&t=汇编语言"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.0.2.</span> <span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">指令和数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-number">1.0.5.</span> <span class="toc-text">存储单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.0.6.</span> <span class="toc-text">CPU对存储器的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF"><span class="toc-number">1.0.7.</span> <span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF"><span class="toc-number">1.0.8.</span> <span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.0.9.</span> <span class="toc-text">控制总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.10.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">CPU内部工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU%E6%A6%82%E8%BF%B0"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">CPU概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">寄存器概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.0.2.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">2.0.3.</span> <span class="toc-text">几条汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">2.0.3.0.1.</span> <span class="toc-text">物理地址</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.3.0.1.1.</span> <span class="toc-text">一个问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.0.4.</span> <span class="toc-text">段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.4.0.1.</span> <span class="toc-text">段的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">2.0.4.0.1.1.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CS%E5%92%8CIP"><span class="toc-number">2.0.4.0.1.2.</span> <span class="toc-text">CS和IP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">2.0.5.</span> <span class="toc-text">代码段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">3.</span> <span class="toc-text">寄存器(内存访问)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E5%92%8C-address"><span class="toc-number">3.0.1.</span> <span class="toc-text">DS和[address]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mov%E3%80%81add%E3%80%81sub%E6%8C%87%E4%BB%A4"><span class="toc-number">3.0.2.</span> <span class="toc-text">mov、add、sub指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.0.3.</span> <span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.0.4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E8%B6%8A%E7%95%8C"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">栈顶越界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push%E3%80%81pop"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">push、pop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">3.0.4.2.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%AE%B5"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">栈段</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.0.2.</span> <span class="toc-text">源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">伪指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">汇编指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">标号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">4.0.2.4.</span> <span class="toc-text">程序返回</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">[BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bx"><span class="toc-number">5.0.1.</span> <span class="toc-text">[bx]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop"><span class="toc-number">5.0.2.</span> <span class="toc-text">loop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.0.2.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88"><span class="toc-number">5.0.3.</span> <span class="toc-text">loop和[bx]的联合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-number">5.0.4.</span> <span class="toc-text">段前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">段前缀的使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">6.0.2.</span> <span class="toc-text">在代码段中使用数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">6.0.3.</span> <span class="toc-text">在代码段中使用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="toc-number">6.0.4.</span> <span class="toc-text">将数据、代码、栈放入不同的段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#And%E5%92%8COr%E6%8C%87%E4%BB%A4"><span class="toc-number">7.0.1.</span> <span class="toc-text">And和Or指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#And%EF%BC%9A%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%8C%E6%8C%89%E4%BD%8D%E8%BF%9B%E8%A1%8C%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">And：逻辑与，按位进行与运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Or%EF%BC%9A%E9%80%BB%E8%BE%91%E6%88%96%EF%BC%8C%E6%8C%89%E4%BD%8D%E8%BF%9B%E8%A1%8C%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">Or：逻辑或，按位进行或运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">应用：大小写转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bx-idata"><span class="toc-number">7.0.2.</span> <span class="toc-text">[bx+idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SI%E5%92%8CDI"><span class="toc-number">7.0.3.</span> <span class="toc-text">SI和DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.4.</span> <span class="toc-text">不同寻址方式的灵活应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bx%E3%80%81si%E3%80%81di%E5%92%8Cbp"><span class="toc-number">8.0.1.</span> <span class="toc-text">bx、si、di和bp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">8.0.2.</span> <span class="toc-text">汇编中数据位置的表达</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0-idata"><span class="toc-number">8.0.2.1.</span> <span class="toc-text">立即数(idata)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">8.0.2.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%EF%BC%88SA%EF%BC%89%E5%92%8C%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%EF%BC%88EA%EF%BC%89"><span class="toc-number">8.0.2.3.</span> <span class="toc-text">段地址（SA）和偏移地址（EA）</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        汇编语言
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">psych</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-01-15T13:56:18.000Z" class="dt-published" itemprop="datePublished">2024-01-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E8%AF%BE%E5%86%85/">课内</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a>, <a class="p-category" href="/tags/%E8%AF%BE%E5%86%85/" rel="tag">课内</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>【8086汇编入门】</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效的控制系统进行运作。</p>
<p>&#x3D;&#x3D;机器语言&#x3D;&#x3D;</p>
<p>机器语言是机器指令的集合。展开来说就是一台机器可以正确执行的命令</p>
<p>&#x3D;&#x3D;汇编语言&#x3D;&#x3D;</p>
<ul>
<li>汇编语言的主体是汇编指令</li>
<li>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式</li>
</ul>
<p>&#x3D;&#x3D;寄存器&#x3D;&#x3D;</p>
<p>寄存器简单来说就是CPU中可以存储数据的器件，一个CPU中有多个寄存器。</p>
<ul>
<li>CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。</li>
<li>运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行<strong>信息存储</strong>；</li>
</ul>
<h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>汇编语言由一下三类组成：</p>
<ul>
<li>汇编指令(机器码的助记符)</li>
<li>伪指令(由编译器执行)</li>
<li>其他符号(由编译器识别，没有对用的机器码)</li>
</ul>
<p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>CPU 是计算机的核心部件，控制计算机的运作并进行运算。指令和数据再存储器中存放，也就是平时说的内存</p>
<p>一台PC机中内存的作用仅次于CPU，离开了内存，CPU无法运作。而磁盘不同于内存，磁盘上的数据库程序如果不读到内存中，就无法被CPU使用。</p>
<ul>
<li>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</li>
<li>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030133241106.png" alt="image-20231030133241106" style="zoom: 25%;" />

<h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><ul>
<li>指令和数据是应用上的概念</li>
<li>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。</li>
</ul>
<h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>存储器被划分为若干个存储单元，每个存储单元从0开始编号</p>
<p>存储容量转换</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1KB = 1024B</span><br><span class="line">1MB = 1024KB</span><br><span class="line">1GB = 1024MB</span><br><span class="line">1TB = 1024GB</span><br></pre></td></tr></table></figure>

<h3 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h3><p>CPU要从内存中读取数据，首先要指定存储单元的地址。也就是它要确定读取哪一个存储单元的数据。</p>
<p>另外，在一台微机中，不只有存储器这一种器件，CPU在读写数据时还要指明，它要对哪一个器件进行操作。</p>
<p>还要确定进行的是那种操作，是从中读出数据，还是向里面写入数据。</p>
<p>可见，CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行三类信息的交互：</p>
<ul>
<li>存储单元的地址(地址信息)</li>
<li>器件的选择，读或写命令(控制信息)</li>
<li>读或写的数据(数据信息)</li>
</ul>
<p>CPU是通过什么将地址、数据和控制信息传到存储器芯片中的呢?计算机中专门有连接CPU和其他芯片的导线，称为总线。逻辑上分为三类：地址总线，控制总线和数据总线</p>
<h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><ul>
<li>CPU是通过地址总线指定存储单元的</li>
<li>地址总线上能传送多少个不同的信息，CPU就可以对多少和存储单元进行寻址<ul>
<li>一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N</li>
<li>这样的 CPU最多可以寻找2的N次方个内存单元</li>
</ul>
</li>
</ul>
<h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><ul>
<li>CPU与内存或其他器件之间的数据川总是通过数据总线来进行的</li>
<li>数据总线的宽度决定了CPU和外界的数据传送数据</li>
</ul>
<h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><ul>
<li>CPU对外部器件的控制是通过控制总线来进行的，在这里控制总线是一个总称，控制总线是一些不同控制线的集合</li>
<li>有多少根控制总线，就意味着CPU提供了对外部前进的多少种控制，控制总线的宽度决定了CPU对外部器件的控制能力</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>汇编指令是机器指令的<strong>助记符</strong>，同机器指令一一对应</li>
<li>每一种CPU都有自己的汇编指令集</li>
<li>CPU可以直接使用的信息是在<strong>存储器</strong>中存放的</li>
<li>在存储器中指令和数据没有任何区别，都是二进制信息</li>
<li>一个CPU可以引出三种不同的总线的宽度标志了这个CPU的不同方面的性能<ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其他器件进行数据传传送的一次数据传送量</li>
<li>控制总线宽度决定了CPU对系统中其他器件的控制能力</li>
</ul>
</li>
</ul>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h3 id="CPU内部工作原理"><a href="#CPU内部工作原理" class="headerlink" title="CPU内部工作原理"></a>CPU内部工作原理</h3><h5 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h5><p>一个典型的CPU由<strong>运算器，控制器，寄存器</strong>等器件组成，这些器件由内部总线相连。而第一章说的总线对于CPU来说是外部总线。</p>
<ul>
<li>内部总线实现CPU内部各个器件之间的联系</li>
<li>外部总线实现CPU和主板上其他器件的联系</li>
</ul>
<p>在CPU内部:</p>
<ul>
<li>运算器进行信息处理</li>
<li>寄存器进行信息存储</li>
<li>控制器控制着各种器件进行工作</li>
</ul>
<h5 id="寄存器概述"><a href="#寄存器概述" class="headerlink" title="寄存器概述"></a>寄存器概述</h5><p>8086CPU有14个寄存器，它们的名称为：</p>
<p>AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>[AX,BX,CX,DX]</p>
<ul>
<li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节(一个字)</p>
<ul>
<li>为保持兼容性，这四个通用寄存器都可以分为两个独立的8位寄存器使用</li>
</ul>
</li>
<li><p>AX,BX,CX,DX通常用来存放一般性数据，被称为通用寄存器</p>
<ul>
<li>AX可以分为AH和AL(兼容性考虑)    其他三个同理</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231030135425947.png" alt="image-20231030135425947" style="zoom: 25%;" /></li>
</ul>
<p>16位结构CPU具有下面几方面的结构特性。</p>
<ul>
<li>运算器一次最多可以处理16位的数据；</li>
<li>寄存器的最大宽度为16位；</li>
<li>寄存器和运算器之间的通路为16位。</li>
</ul>
<h3 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h3><table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="center">控制CPU完成的操作</th>
<th align="center">用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov ax , 18</td>
<td align="center">将18送入AX</td>
<td align="center">AX &#x3D; 18</td>
</tr>
<tr>
<td align="center">mov ah , 78</td>
<td align="center">将78送入AH</td>
<td align="center">AH &#x3D; 78</td>
</tr>
<tr>
<td align="center">add ah , 8</td>
<td align="center">将寄存器AX中的数值加8</td>
<td align="center">AX &#x3D; AX + 8</td>
</tr>
<tr>
<td align="center">mov ax , bx</td>
<td align="center">将寄存器BX中的数据送入AX</td>
<td align="center">AX &#x3D; BX</td>
</tr>
<tr>
<td align="center">add ax , bx</td>
<td align="center">将AX,BX中的内容相加，结果放在AX中</td>
<td align="center">AX &#x3D; AX + BX</td>
</tr>
</tbody></table>
<h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><ul>
<li>CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间</li>
<li>我们将这个唯一的地址称为物理地址</li>
</ul>
<h6 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h6><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。<br>8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。<br>从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。</p>
<blockquote>
<p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址</p>
</blockquote>
<ul>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址；</li>
</ul>
<p>地址加法器合成物理地址的方法：</p>
<p><code>物理地址 = 段地址 × 16 + 偏移地址</code></p>
<p>其中<code>段地址× 16 </code>有一个更常用的说法就是数据左移4位，16进制的话就是左移1位。</p>
<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240111183554301.png" alt="image-20240111183554301" style="zoom:33%;" />

<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><h5 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h5><p>内存并没有分段，段的划分来自于CPU，由于8086CPU用<code>物理地址 = 段地址 × 16 + 偏移地址</code>的方式给出内存单元的物理地址，使得我么可以用<strong>分段的方式来管理内存</strong>。</p>
<ul>
<li>段地址 × 16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数</li>
<li>偏移地址为16位，16位地址的寻址能力为64kb，左移一个段的长度最大为64kb</li>
</ul>
<h6 id="段寄存器-1"><a href="#段寄存器-1" class="headerlink" title="段寄存器"></a>段寄存器</h6><p>段寄存器就是提供段地址的。8086CPU有4个段寄存器，<code>CS,DC,SS,ES</code>当8086CPU要访问内存是，由这4个段寄存器提供内存单元的段地址</p>
<h6 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h6><blockquote>
<p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址</p>
</blockquote>
<ul>
<li>CS为代码段寄存器</li>
<li>IP为指令指针寄存器</li>
</ul>
<p>CS为代码段寄存器，IP为指令指针寄存器，</p>
<p>CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,</p>
<p>CPU将CS : IP指向的内容当作指令执行。(即PC)</p>
<p>&#x3D;&#x3D;工作过程&#x3D;&#x3D;</p>
<ul>
<li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器。</li>
<li>IP &#x3D; IP + 读取的指令的长度，从而指向下一条指令。</li>
<li>执行指令，转到步骤1，重复这个过程。</li>
</ul>
<p>&#x3D;&#x3D;修改CS和IP的指令&#x3D;&#x3D;</p>
<ul>
<li><p>在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制</p>
</li>
<li><p>CPU从何处执行指令是由CS、IP中的内容决定的，程序员通过改变CS、IP中的内容来控制CPU</p>
</li>
<li><p><code>MOV</code>指令可以改变8089CPU大部分寄存器的值，被称为传送指令，但是不能通过<code>MOV</code>指令改变CS、IP的值</p>
</li>
<li><p>8086提供了专门的转移指令来修改CS、IP的值</p>
</li>
<li><p>同时修改CS、IP的内容：<br><code>jmp 段地址:偏移地址</code><br>jmp 2AE3:3        -&gt;     从2AE33H处读取指令<br>jmp 3:0B16        -&gt;     从00B46H处读取指令</p>
<p><strong>功能：用指令中给出的段地址修改CS，偏移地址修改IP</strong></p>
</li>
<li><p>仅修改IP的内容</p>
<p><code>jmp 某一合法寄存器</code></p>
<p>jmp ax (类似于 mov IP，ax)</p>
<p>功能：用寄存器中的值修改IP</p>
</li>
</ul>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><ul>
<li>对于8086CPU机，在编程时，可以根据需要，将一组内存单元定义为一个段</li>
<li>可以将长度为N的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</li>
</ul>
<h1 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h1><h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><ul>
<li>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址</li>
<li>在8086CPU中，内存地址由段地址和偏移地址组成</li>
<li>8086CPU中有一个<strong>DS寄存器</strong>，通常用来存放要访问的数据的段地址</li>
</ul>
<p>例如：我们要读取10000H单元的内容可以用如下程序进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx    ;为什么要转一次？8086不支持将数据直接送入段寄存器</span><br><span class="line">mov al, [0]    ;将10000H(1000:0)中的数据读到al中</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>前面已知mov指令可以将<strong>数据直接送入寄存器</strong>，或者<strong>将一个寄存器中的内容送入另一个寄存器</strong></li>
<li>除此之外，mov指令还可以将一个<strong>内存单元</strong>中的内容送入一个寄存器</li>
<li>格式：<code>mov 寄存器名,内存单元地址</code></li>
<li>[···]表示一个内存单元，“[···]”中的0表示内存单元的偏移地址</li>
<li>而CPU自动读取DS中的数据作为内存单元的段地址</li>
<li>此时，读取到的内存单元就是：DS:偏移地址</li>
</ul>
<h3 id="mov、add、sub指令"><a href="#mov、add、sub指令" class="headerlink" title="mov、add、sub指令"></a>mov、add、sub指令</h3><p>mov已学的几种指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,数据     ;mov ax 8</span><br><span class="line">mov 寄存器,寄存器    ;mov ax,bx</span><br><span class="line">mov 寄存器,内存单元  ;mov ax,[0]  ;反过来也是可以的</span><br><span class="line">mov 段寄存器,寄存器  ;mov ds,ax   ;反过来也是可以的</span><br></pre></td></tr></table></figure>

<p>add和sub同mov一样，都有两个操作对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器,数据       ;add ax,8</span><br><span class="line">add 寄存器,寄存器      ;add ax,bx</span><br><span class="line">add 寄存器,内存单元    ;add ax,[0]</span><br><span class="line">add 内存单元,寄存      ;add [0],ax</span><br></pre></td></tr></table></figure>

<h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>对于8086CPU，我们可以根据需要将一组内存单元定义为一个段(可以是代码段、数据段等)</p>
<p>我们可以将一组长度为N、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。</p>
<p>比如用123B0H~123B9H这段空间来存放数据：</p>
<ul>
<li>段地址：123BH</li>
<li>长度：10字节</li>
</ul>
<blockquote>
<p>数据段的访问</p>
</blockquote>
<p>例如：将123B0H~123B9H的内存空间定义为数据段，并累加这个数据段中前三个单元中的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax   ;定义数据段的段地址</span><br><span class="line">mov al,0   ;用al存放累加结果</span><br><span class="line">add al,[0]  ;为什么用al？用ax的话是16位，那么取[0]的数据(8位)的时候会自动加上高位一起</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>特性：先进后出(LIFO)	last in first out</p>
<p>8086CPU提供入栈和出栈的指令(最基本的)：[入栈和出栈的操作都是以字节为单位进行的]</p>
<p>PUSH (入栈)</p>
<p>​		<code>push ax</code>  将寄存器ax中的数据送入栈中</p>
<p>POP (出栈) </p>
<p>​		<code>pop ax</code>从栈顶去除数据送入ax。</p>
<p><strong>cpu如何知道当前要执行的指令所在的位置？</strong></p>
<p>答：寄存器CS和IP中存放着当前指令的段地址和偏移地址</p>
<p>8086CPU中，有两个寄存器：</p>
<ul>
<li>段寄存器SS	存放栈顶的段地址</li>
<li>寄存器SP    存放栈顶的偏移地址</li>
</ul>
<p><code>任意时刻：SS:SP指向栈顶元素</code></p>
<p>&#x3D;&#x3D;pop指令的执行过程[push同理]&#x3D;&#x3D;</p>
<p><code>pop ax</code></p>
<ul>
<li>将SS:SP指向的内存单元处的数据送入ax中</li>
<li>SP&#x3D;SP+2[push的话就是SP-2]，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20231031135144429.png" alt="image-20231031135144429" style="zoom:25%;" />

<h4 id="栈顶越界"><a href="#栈顶越界" class="headerlink" title="栈顶越界"></a>栈顶越界</h4><p>8086CPU的工作机理：只考虑当前的情况</p>
<ul>
<li>当前栈顶在何处</li>
<li>当前要执行的指令是那一条</li>
<li>CPU并不会知道栈顶在哪里    —&gt;    存在栈溢出的问题</li>
</ul>
<h4 id="push、pop"><a href="#push、pop" class="headerlink" title="push、pop"></a>push、pop</h4><p>&#x3D;&#x3D;push和pop指令的格式(1)&#x3D;&#x3D;</p>
<ul>
<li><code>push 寄存器</code>  将一个寄存器中的数据入栈         ;push ax</li>
<li><code>pop 寄存器</code>  出栈，用一个寄存器接收出栈的数据        ;pop bx</li>
</ul>
<p>&#x3D;&#x3D;push和pop指令的格式(2)&#x3D;&#x3D;</p>
<ul>
<li><code>push 段寄存器</code>  将一个段寄存器中的数据入栈        ;push ds</li>
<li><code>pop 段寄存器</code>出栈，用一个段寄存器接收出栈的数据          ;pop es</li>
</ul>
<p>&#x3D;&#x3D;push和pop指令的格式(3)&#x3D;&#x3D;</p>
<ul>
<li><code>push 内存单元</code>  将一个内存单元处的<strong>字</strong>入栈[栈操作都是以字为单位]        ;push [0]</li>
<li><code>pop 内存单元</code>出栈，用一个内存字单元接收出栈的数据       ;pop [2]</li>
</ul>
<p>指令实行时，CPU要知道内存单元的地址，可以在push，pop指令中给出内存单元的偏移地址，段地址在指令执行的手CPU从ds中取得</p>
<h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>将10000H~1000FH这段空间当做栈，初始状态是空的，设置AX&#x3D;002AH，BX&#x3D;002BH，利用栈，交换AX和BX中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0010H        ;初始化栈顶SS:SP指向10010H</span><br><span class="line">mov ax,002AH          </span><br><span class="line">mov bx,002BH</span><br><span class="line">push ax             ;ax的值传进去002AH</span><br><span class="line">push bx             ;bx的值传入002BH</span><br><span class="line">pop ax              ;出栈,把栈顶数据002BH[原来ax的数据]传给ax</span><br><span class="line">pop bx              ;同上</span><br></pre></td></tr></table></figure>

<h4 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h4><p>我们可以将一组长度为N、地址连续、起始地址为16的倍数的内存单元当做栈来使用，从而定义了一个栈段。</p>
<h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>一个汇编语言程序从写出到最终执行的简要过程：</p>
<ul>
<li>编写    —&gt;    .asm</li>
<li>编译连接    —&gt;    对源程序文件中的源程序进行编译产生目标文件    —&gt;    .ogj    —&gt;    再用连接程序对目标文件进行连接，生成可执行文件    —&gt;    .exe<ul>
<li>可执行文件包含两个部分：<ul>
<li>程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据)</li>
<li>相关的描述信息(比如：程序的大小和占用的内存空间等)</li>
</ul>
</li>
</ul>
</li>
<li>执行    —&gt;    操作系统依照客户自行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化(比如：设置CS:IP指向第一条要执行的指令)，然后由CPU执行程序</li>
</ul>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;1.asm</span><br><span class="line">assume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。</span><br><span class="line"></span><br><span class="line">codesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始</span><br><span class="line">			   ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址</span><br><span class="line"></span><br><span class="line">	mov ax, 0123H</span><br><span class="line">	mov bx, 0456H </span><br><span class="line">	add ax, bx</span><br><span class="line">	add ax, ax </span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00H </span><br><span class="line">	int 21H ;这两条指令实现程序的返回</span><br><span class="line">	</span><br><span class="line">codesg ends ;名称为“codesg”的段到此结束</span><br><span class="line"></span><br><span class="line">end ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p>在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是。伪指令没有对应的机器码的指令，最终不被CPU执行。伪指令是由<strong>编译器</strong>来执行的指令，编译器根据伪指令来进行相关的编译工作。</p>
<p>&#x3D;&#x3D;定义一个段&#x3D;&#x3D;</p>
<ul>
<li>**<code>segment</code><strong>和</strong><code>ends</code>**是一对成对使用的伪指令，这是在写可以被编译器编译的汇编程序时，必须用到的一对伪指令</li>
<li><strong><code>segment</code><strong>和</strong><code>ends</code><strong>的功能是</strong>定义一个段</strong>，segment说明一个段的开始，ends说明一个段的结束</li>
<li>一个段必须有一个名称来标识，使用格式为：<ul>
<li><code>段名 segment</code></li>
<li><code>段名 ends</code></li>
</ul>
</li>
<li>一个汇编程序由多个段组成，这些段用来存放代码、数据或被当做栈空间使用。但是一个程序至少有一个段</li>
</ul>
<p>&#x3D;&#x3D;End&#x3D;&#x3D;</p>
<ul>
<li>End是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译</li>
<li>注意不要搞混了end和ends。ends是和segment成对使用的标记一个段的结束，ends可以理解为<code>end segment</code></li>
</ul>
<p>&#x3D;&#x3D;assume&#x3D;&#x3D;</p>
<ul>
<li><code>assume</code>:含义为’假设’</li>
<li>它假设某一段寄存器和程序中的某一个用<code>segment···ends</code>定义的段相关联</li>
<li>通过<code>assume</code>说明这种关联，在需要的情况下，编译程序可以将带寄存器和某个具体的段相关联</li>
<li>assume并不是一条非要深入理解不可的伪指令，以后我们编程的时候，记得用特定用途的段和相关的段寄存器关联起来即可</li>
<li><code>assume cs:codesg </code>  将用作代码段的段codesg和段寄存器cs联系起来。</li>
</ul>
<h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><p>有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br></pre></td></tr></table></figure>

<p>这些就是一些汇编指令，可以和机器指令一一对应</p>
<h4 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h4><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如”codesg”</p>
<ul>
<li>一个标号指代了一个地址</li>
<li>codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:psych</span><br><span class="line">aaa segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">psych ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么它怎么得到运行呢？</p>
<ul>
<li>DOS中的程序运行</li>
</ul>
<p>DOS是一个单任务操作系统。一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行。当P2运行完毕后，应该将CPU的控制权交换给它使它得以运行的程序P1，此后P1继续运行。</p>
<p>现在我们知道，一个程序结束后，将CPU的控制权交还给使他得以运行的程序，我们称这个过程为：程序返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;在程序的末尾天界返回的程序段。</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H  </span><br><span class="line">;这两条指令所实现的功能就是程序返回</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;段结束、程序结束、程序返回&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th align="center">目的</th>
<th align="center">相关指令</th>
<th align="center">指令性质</th>
<th align="center">执行执行者</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通知编译器一个段结束</td>
<td align="center">段名 ends</td>
<td align="center">伪指令</td>
<td align="center">编译时，由编译器执行</td>
</tr>
<tr>
<td align="center">通知编译器程序结束</td>
<td align="center">end</td>
<td align="center">伪指令</td>
<td align="center">编译时，由编译器执行</td>
</tr>
<tr>
<td align="center">程序返回</td>
<td align="center">mov ax,4c00H       int 21H</td>
<td align="center">汇编指令</td>
<td align="center">编译时，由CPU执行</td>
</tr>
</tbody></table>
<h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><h3 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h3><p><strong>[bx]</strong> 的含义：[bx]和[0]类似，同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p>
<p><code>mov ax, [bx]</code></p>
<p>​	功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。即<code>(ax) =((ds)*16+(bx)) </code></p>
<p>注：在以后的课程中，我们将使用一个描述性的符号”( )”来表示一个寄存器或一个内存单元的内容。比如：(ax)表示ax中的内容、(20000H)表示2000H中的内容；</p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>英文单词’loop’有循环的含义，显然这个指令和循环有关。</p>
<p>loop指令的格式是：<code>loop 标号</code>，CPU执行loop指令的时候，要进行两步操作</p>
<ul>
<li>(cx) &#x3D; (cx) - 1;</li>
<li>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>
</ul>
<p>我们可以发现，cx中的值影响着loop指令的执行结果。通常我们用loop指令来实现循环功能，cx中存放循环次数。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>任务：编程计算2^12，结果存放在ax中。</p>
<p>分析：</p>
<p>N^2可以用N+N表示，设(ax) &#x3D; 2,(ax) &#x3D; (ax)+(ax)，</p>
<p>2^4可以用<code>2*2*2*2</code>表示，上一步执行得到的(ax)再次执行两次(ax) &#x3D; (ax) + (ax)</p>
<p>也就是2^12就是2乘11次2，总共执行11次(ax)&#x3D;(ax)+(ax);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">	mov ax,2</span><br><span class="line">	</span><br><span class="line">	mov cx,11	</span><br><span class="line"> s: add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>程序中标号<code>s</code>实际上标示了一个地址，这个地址由一条指令：add ax,ax;</li>
<li>loop s 程序在执行这条指令时，先cx-1，不为零，执行标号的指令，再继续cx-1，一直到cx&#x3D;0，总共循环了10次，但是刚开始执行了一次，故总共执行了11次，正好等于cx</li>
</ul>
<h3 id="loop和-bx-的联合"><a href="#loop和-bx-的联合" class="headerlink" title="loop和[bx]的联合"></a>loop和[bx]的联合</h3><p>问题：计算ffff:0~ffff:b单元中的数据和，结果存储在dx中</p>
<p>分析：</p>
<ul>
<li>ffff:0<del>ffff:b中的数据都是8位的，不能直接加到寄存器dx中，而先累加到dl中设置(dh)&#x3D;0也不行，ffff:0</del>ffff:b数据范围在0~255，12个8位数据相加可能导致进位丢失</li>
<li>目前的方法是用一个16位的寄存器来做中介。将内存单元中的8位数据赋值到16位寄存器ax中，再将ax中的数据加到dx中，从而使这两种运算对象的类型匹配且不会发生越界</li>
<li>还有一个问题就是所有数据和加起来构成循环，可以使用loop来简化程序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	</span><br><span class="line">	mov ax,0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0    ;初始化ds:bx指向ffff:0</span><br><span class="line">	mov dx,0    ;初始化累加寄存器dx,(dx) = 0</span><br><span class="line">	mov cx,12   ;初始化循环计数寄存器cx,(cx) = 12</span><br><span class="line"> s: mov al,[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add dx,ax   ;间接向dx中加上((ds)*16+(bx))单元的数值</span><br><span class="line">	inc bx      ;ds:bx指向下一个单元</span><br><span class="line">	loop s</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>指令<code>mov ax,[bx]</code>中，内存单元的偏移地址由bx给出，而段地址默认在ds中。我们可以在访问内存单元的指令中显式的给出内存单元的段地址所在的段寄存器。比如：</p>
<ul>
<li><p><code>mov ax,ds:[bx]</code></p>
<p>将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个字，偏移地址在bx中，段地址在ds中。</p>
</li>
</ul>
<p>类似的还有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, ds:[bx]</span><br><span class="line">mov ax, cs:[bx]</span><br><span class="line">mov ax, ss:[bx]</span><br><span class="line">mov ax, es:[bx]</span><br><span class="line">mov ax, ss:[0]</span><br><span class="line">mov ax, cs:[0]</span><br></pre></td></tr></table></figure>

<p>这些出现在访问内存单元的指令中，用于显示的指明内存单元的段地址的”ds”,”cs”,”ss”,”es”，在汇编语言中称为段前缀。</p>
<h4 id="段前缀的使用"><a href="#段前缀的使用" class="headerlink" title="段前缀的使用"></a>段前缀的使用</h4><p>问题：将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p>
<p>分析：</p>
<ul>
<li>复制的过程应用循环实现<ul>
<li>x&#x3D;0</li>
<li>循环十二次：<ul>
<li>将ffff:x中的数据送入0020:X(需要用一个寄存器中转)</li>
<li>X&#x3D;X+1</li>
</ul>
</li>
</ul>
</li>
<li>在循环中，X是变量，我们哟bx存放</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov bx,0    ;(bx)=0,偏移地址从0开始</span><br><span class="line">	mov cx,12   ;循环12次</span><br><span class="line">	</span><br><span class="line">s:  mov ax,0ffffh</span><br><span class="line">	mov ds,ax   ;(ds)=0fffffh</span><br><span class="line">	mov dl,ax   ;(dl)=((ds)*16+(bx)),将ffff:bx中的数据传入dl</span><br><span class="line">	</span><br><span class="line">	mov ax,0020H</span><br><span class="line">	mov ds,ax   ;(ds)=0020H</span><br><span class="line">	mov [bx],dl ;((ds)*16+(bx))=(dl),将dl的数据传入0020:bx</span><br><span class="line">	</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>程序取得所需空间的方式有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。这里我们主要研究第一种方式，加载程序的时候为程序分配空间</li>
<li>我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中作出说明。我们通过源程序中定义段来进行内存空间的获取。</li>
</ul>
<p>程序中对段名的引用，被编译器处理为一个表示段地址的数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, ds:[6]</span><br></pre></td></tr></table></figure>

<h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>计算8个数据的和，结果存储在AX寄存器中。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;计算 8 个数据的和存到 ax 寄存器</span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line"></span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据</span><br><span class="line">	                                                   ;所占的内存空间大小为16个字节</span><br><span class="line"></span><br><span class="line">	start:	mov bx, 0  ;标号start。告诉CPU从这里开始，否则上面的dw存的数据会被当做代码</span><br><span class="line">			mov ax, 0  </span><br><span class="line">			</span><br><span class="line">			mov cx, 8</span><br><span class="line">	s:		add ax, cs:[bx]</span><br><span class="line">			add bx, 2</span><br><span class="line">			loop s </span><br><span class="line">			</span><br><span class="line">			mov ax, 4c00h </span><br><span class="line">			int 21h </span><br><span class="line">code ends</span><br><span class="line">end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span><br><span class="line">	     	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</span><br></pre></td></tr></table></figure>

<h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;利用栈，将程序中定义的数据逆序存放。</span><br><span class="line">assume cs:codesg </span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">	dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元</span><br><span class="line">	dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用</span><br><span class="line">			</span><br><span class="line">	start:	mov ax, cs </span><br><span class="line">			mov ss, ax </span><br><span class="line">			mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d</span><br><span class="line">			mov bx, 0</span><br><span class="line">			</span><br><span class="line">			mov cx, 8</span><br><span class="line">	s:		push cs:[bx]</span><br><span class="line">			add bx, 2</span><br><span class="line">			loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line">			</span><br><span class="line">			mov bx, 0</span><br><span class="line">			</span><br><span class="line">			mov cx, 8</span><br><span class="line">	s0:		pop cs:[bx]		</span><br><span class="line">			add bx，2</span><br><span class="line">			loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中</span><br><span class="line">			</span><br><span class="line">			mov ax，4c00h </span><br><span class="line">			int 21h </span><br><span class="line">codesg ends </span><br><span class="line">end start	;指明程序的入口在start处</span><br></pre></td></tr></table></figure>

<h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack    ;定义三个段</span><br><span class="line"></span><br><span class="line">data segment </span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;0-15单元</span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">stack segment </span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;0-31单元</span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">	start:	mov ax, stack;将名称为“stack”的段的段地址送入ax</span><br><span class="line">			mov ss, ax</span><br><span class="line">			mov sp, 20h  ;设置栈顶ss:sp指向stack:20。 20h = 32d</span><br><span class="line">			</span><br><span class="line">			mov ax, data ;将名称为“data”的段的段地址送入ax</span><br><span class="line">			mov ds, ax   ;ds指向data段</span><br><span class="line">			</span><br><span class="line">			mov bx, 0    ;ds:bx指向data段中的第一个单元</span><br><span class="line">			</span><br><span class="line">			mov cx, 8</span><br><span class="line">	s:	    push [bx]</span><br><span class="line">			add bx, 2</span><br><span class="line">			loop s       ;以上将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line">			</span><br><span class="line">			mov bx, 0</span><br><span class="line">			</span><br><span class="line">			mov cx, 8</span><br><span class="line">	s0:		pop [bx]</span><br><span class="line">			add bx, 2</span><br><span class="line">			loop s0      ;以上依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line">			</span><br><span class="line">			mov ax, 4c00h </span><br><span class="line">			int 21h </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</span><br><span class="line">;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</span><br></pre></td></tr></table></figure>



<h1 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h1><p>前面，我们用[0]、[bx]的方法，在访问内存的指令中，定位内存单元的地址。本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法。</p>
<h3 id="And和Or指令"><a href="#And和Or指令" class="headerlink" title="And和Or指令"></a>And和Or指令</h3><h4 id="And：逻辑与，按位进行与运算"><a href="#And：逻辑与，按位进行与运算" class="headerlink" title="And：逻辑与，按位进行与运算"></a>And：逻辑与，按位进行与运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure>

<p>执行后，al&#x3D;00100011B</p>
<h4 id="Or：逻辑或，按位进行或运算"><a href="#Or：逻辑或，按位进行或运算" class="headerlink" title="Or：逻辑或，按位进行或运算"></a>Or：逻辑或，按位进行或运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">or  al,00111011B</span><br></pre></td></tr></table></figure>

<p>执行后，al&#x3D;01111011B</p>
<h4 id="应用：大小写转换"><a href="#应用：大小写转换" class="headerlink" title="应用：大小写转换"></a>应用：大小写转换</h4><img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/20190321194022547.png" alt="20190321194022547" style="zoom: 80%;" />

<p>小写字母的ASCII码值比大写字母的ASCII码值大20H</p>
<p>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg </span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;iNfOrMaTion&#x27;</span><br><span class="line">datasg end</span><br><span class="line"> </span><br><span class="line">codesg segment </span><br><span class="line">	start:	mov ax, datasg </span><br><span class="line">			mov ds, ax	;设置ds 指向 datasg段</span><br><span class="line">		</span><br><span class="line">			mov bx, 0	;设置（bx）=0，ds:bx指向’BaSic’的第一个字母</span><br><span class="line">			</span><br><span class="line">			mov cx, 5     	 ;设置循环次数5，因为’Basic&#x27;有5个字母</span><br><span class="line">	s:		mov al, [bx]     ;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">			and al, 11011111B;将al中的ASCII码的第5位置为0，变为大写字母</span><br><span class="line">			mov [bx], al	 ;将转变后的ASCII码写回原单元</span><br><span class="line">			inc bx		     ;（bx）加1，ds:bx指向下一个字母</span><br><span class="line">			loop s </span><br><span class="line">			</span><br><span class="line">			mov bx, 5	;设置（bx）=5，ds:bx指向，iNfOrMaTion&#x27;的第一个字母</span><br><span class="line">			</span><br><span class="line">			mov cx, 11	;设置循环次数11，因为‘iNfOrMaTion&#x27;有11个字母</span><br><span class="line">	s0:		mov al, [bx]</span><br><span class="line">			or al, 00100000B;将a1中的ASCII码的第5位置为1，变为小写字母</span><br><span class="line">			mov [bx], al </span><br><span class="line">			inc bx</span><br><span class="line">			loop s0</span><br><span class="line">			</span><br><span class="line">			mov ax, 4c00h </span><br><span class="line">			int 21h </span><br><span class="line">codesg ends</span><br></pre></td></tr></table></figure>

<h3 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h3><p>前面，我们用[bx]的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元；[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata(bx中的数值加上idata)</p>
<p><code>mov ax,[bx+200]</code></p>
<p>含义：将一个内存单元的内容送入ax，这个内存单元的长度为2个自己(字单元)，存放一个字，偏移地址为bx总的数值加上200，段地址在ds中。</p>
<p>以下写法也很常见：</p>
<p><code>mov ax,[200+bx]</code></p>
<p><code>mov ax,200[bx]</code></p>
<p><code>mov ax,[bx].200</code></p>
<p>这个可以理解为数组，我们利用这个可以用更高级的结构来实现大小写转换程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg </span><br><span class="line"></span><br><span class="line">datasg segment </span><br><span class="line">	db &#x27;BaSiC&#x27;;转为大写</span><br><span class="line">	db &#x27;MinIx&#x27;;转为小写</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax, datasg </span><br><span class="line">		mov ds, ax </span><br><span class="line">		mov bx, 0  ;初始ds:bx</span><br><span class="line">	</span><br><span class="line">		mov cx, 5</span><br><span class="line">	s:	mov al, 0[bx]  </span><br><span class="line">		and al, 11011111b ;转为大写字母</span><br><span class="line">		mov 0[bx], al ;写回</span><br><span class="line">		mov al, 5[bx]  ;[5 + bx]</span><br><span class="line">		or al, 00100000b ;转为小写字母</span><br><span class="line">		mov 5[bx], al </span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax, 4c00h </span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>对比以下汇编和C语言对数组的写法</p>
<p>C语言:  <code>a[i], b[i]</code></p>
<p>汇编:   <code>0[bx], 5[bx]</code></p>
<h3 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h3><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。下面的3组指令实现了相同的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>

<p>下面的三组指令也实现了相同的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[di+123]</span><br></pre></td></tr></table></figure>

<h3 id="不同寻址方式的灵活应用"><a href="#不同寻址方式的灵活应用" class="headerlink" title="不同寻址方式的灵活应用"></a>不同寻址方式的灵活应用</h3><p>如果我们比较前面提到了几种定位内存地址的方法(可称为寻址方式)，就可以发现</p>
<ul>
<li>[idata]用一个常量表示地址，可用于直接定位一个内存单元</li>
<li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li>
<li>[bx+si]用两个变量表示地址</li>
<li>[bx+si+idata]用两个变量和一个常量表示地址</li>
</ul>
<p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p>
<h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><p>我们知道，计算机是尽心数据处理、运算的机器。那么有两个基本的问题就包含在其中：</p>
<ul>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ul>
<p>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。</p>
<p>我们定义的描述性符号：<code>reg</code>和<code>sreg</code></p>
<p>为了描述上的简洁，在以后的课程中，我们将使用描述性的符号<code>reg</code>来表示一个寄存器，用<code>sreg</code>表示一个段寄存器</p>
<p><code>reg</code> 的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di</p>
<p><code>sreg</code>的集合包括：ds、ss、cs、es</p>
<h3 id="bx、si、di和bp"><a href="#bx、si、di和bp" class="headerlink" title="bx、si、di和bp"></a>bx、si、di和bp</h3><p>我们进行一下总结：</p>
<ul>
<li><p>在8086CPU中，只有这4个寄存器可以在[···]中来进行内存单元的寻址</p>
</li>
<li><p>在[···]中，这4个寄存器可以单个实现，或只能以4中组合出现：<code>bx和si</code>、<code>bx和di</code>、<code>bp和si</code>、<code>bp和di</code>。</p>
</li>
<li><p>只要在[···]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中</p>
<p><code>mov ax,[bp]</code>  含义   <code>(ax)=((ss)*16+(bp))</code></p>
</li>
</ul>
<h3 id="汇编中数据位置的表达"><a href="#汇编中数据位置的表达" class="headerlink" title="汇编中数据位置的表达"></a>汇编中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置</p>
<ul>
<li>立即数(idata)</li>
<li>寄存器</li>
<li>段地址(SA)和偏移地址(EA)</li>
</ul>
<h4 id="立即数-idata"><a href="#立即数-idata" class="headerlink" title="立即数(idata)"></a>立即数(idata)</h4><p>对于直接包含在机器指令中的数据(执行前在CPU是直接指令缓冲器中)，在汇编语言中称为：立即数(idata)，在汇编指令中直接给出。例如:</p>
<p><code>mov ax,1</code></p>
<h4 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h4><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：</p>
<p><code>mov ax,bx</code></p>
<h4 id="段地址（SA）和偏移地址（EA）"><a href="#段地址（SA）和偏移地址（EA）" class="headerlink" title="段地址（SA）和偏移地址（EA）"></a>段地址（SA）和偏移地址（EA）</h4><p>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。</p>
<ul>
<li>存放在段地址的寄存器可以是默认的</li>
<li>存放在段地址的寄存器也可以是显性给出的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [0]</span><br><span class="line">mov ax, [di]</span><br><span class="line">mov ax, [bx+8]</span><br><span class="line">mov ax, [bx+si]</span><br><span class="line">mov ax, [bx+si+8]   ;以上段地址默认在ds中</span><br><span class="line"></span><br><span class="line">mov ax, [bp]</span><br><span class="line">mov ax, [bp+8]</span><br><span class="line">mov ax, [bp+si]</span><br><span class="line">mov ax, [bp+si+8]   ;以上段地址默认在ss中</span><br><span class="line"></span><br><span class="line">mov ax, ds:[bp]</span><br><span class="line">mov ax, es:[bx]</span><br><span class="line">mov ax, ss:[bx+si]</span><br><span class="line">mov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/p5ych2022/IHS@master/img/image-20240115220506695.png" alt="image-20240115220506695" style="zoom:50%;" />












  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Article</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.0.2.</span> <span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">指令和数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-number">1.0.5.</span> <span class="toc-text">存储单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.0.6.</span> <span class="toc-text">CPU对存储器的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF"><span class="toc-number">1.0.7.</span> <span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF"><span class="toc-number">1.0.8.</span> <span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.0.9.</span> <span class="toc-text">控制总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.10.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">CPU内部工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU%E6%A6%82%E8%BF%B0"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">CPU概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">寄存器概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.0.2.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">2.0.3.</span> <span class="toc-text">几条汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">2.0.3.0.1.</span> <span class="toc-text">物理地址</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.3.0.1.1.</span> <span class="toc-text">一个问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.0.4.</span> <span class="toc-text">段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.4.0.1.</span> <span class="toc-text">段的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">2.0.4.0.1.1.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CS%E5%92%8CIP"><span class="toc-number">2.0.4.0.1.2.</span> <span class="toc-text">CS和IP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">2.0.5.</span> <span class="toc-text">代码段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">3.</span> <span class="toc-text">寄存器(内存访问)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E5%92%8C-address"><span class="toc-number">3.0.1.</span> <span class="toc-text">DS和[address]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mov%E3%80%81add%E3%80%81sub%E6%8C%87%E4%BB%A4"><span class="toc-number">3.0.2.</span> <span class="toc-text">mov、add、sub指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.0.3.</span> <span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.0.4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E8%B6%8A%E7%95%8C"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">栈顶越界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push%E3%80%81pop"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">push、pop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">3.0.4.2.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%AE%B5"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">栈段</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.0.2.</span> <span class="toc-text">源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">伪指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">汇编指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">标号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">4.0.2.4.</span> <span class="toc-text">程序返回</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">[BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bx"><span class="toc-number">5.0.1.</span> <span class="toc-text">[bx]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop"><span class="toc-number">5.0.2.</span> <span class="toc-text">loop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.0.2.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88"><span class="toc-number">5.0.3.</span> <span class="toc-text">loop和[bx]的联合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-number">5.0.4.</span> <span class="toc-text">段前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">段前缀的使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">6.0.2.</span> <span class="toc-text">在代码段中使用数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">6.0.3.</span> <span class="toc-text">在代码段中使用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="toc-number">6.0.4.</span> <span class="toc-text">将数据、代码、栈放入不同的段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#And%E5%92%8COr%E6%8C%87%E4%BB%A4"><span class="toc-number">7.0.1.</span> <span class="toc-text">And和Or指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#And%EF%BC%9A%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%8C%E6%8C%89%E4%BD%8D%E8%BF%9B%E8%A1%8C%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">And：逻辑与，按位进行与运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Or%EF%BC%9A%E9%80%BB%E8%BE%91%E6%88%96%EF%BC%8C%E6%8C%89%E4%BD%8D%E8%BF%9B%E8%A1%8C%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">Or：逻辑或，按位进行或运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">应用：大小写转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bx-idata"><span class="toc-number">7.0.2.</span> <span class="toc-text">[bx+idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SI%E5%92%8CDI"><span class="toc-number">7.0.3.</span> <span class="toc-text">SI和DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.4.</span> <span class="toc-text">不同寻址方式的灵活应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bx%E3%80%81si%E3%80%81di%E5%92%8Cbp"><span class="toc-number">8.0.1.</span> <span class="toc-text">bx、si、di和bp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">8.0.2.</span> <span class="toc-text">汇编中数据位置的表达</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0-idata"><span class="toc-number">8.0.2.1.</span> <span class="toc-text">立即数(idata)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">8.0.2.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%EF%BC%88SA%EF%BC%89%E5%92%8C%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%EF%BC%88EA%EF%BC%89"><span class="toc-number">8.0.2.3.</span> <span class="toc-text">段地址（SA）和偏移地址（EA）</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&text=汇编语言"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&is_video=false&description=汇编语言"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=汇编语言&body=Check out this article: http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&title=汇编语言"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&name=汇编语言&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://p5ych2022.github.io/2024/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/&t=汇编语言"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    psych
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Article</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>
    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
